package home_work_1;

public class BitwiseOperators {
    public static void main(String[] args) {

        // Положительные числа
        byte n1 = 42;        // в двоичной 00101010
        byte n2 = 15;        // в двоичной 00001111

        // 1. Побитовый унарный оператор NOT
        System.out.println(~n1);        // превращает 00101010 в 11010101 (-43)
        System.out.println(~n2);        // превращает 00001111 в 11110000 (-16)

        // 2. Побитовый AND
        System.out.println(n1 & n2);
        // 00101010     42
        // 00001111     15
        // 00001010     результат (10)
        System.out.println(n1&=n2); // производит операцию и присваивает переменной n1 значение побитового AND
        n1=42; // вернул первоначальное значение переменной

        // 3. Побитовый OR
        System.out.println(n1 | n2);
        // 00101010     42
        // 00001111     15
        // 00101111     результат (47)
        System.out.println(n1|=n2); // производит операцию и присваивает переменной n1 значение побитового OR
        n1=42; // вернул первоначальное значение переменной

        // 4. Побитовый XOR (исключающий OR)
        System.out.println(n1 ^ n2);
        // 00101010     42
        // 00001111     15
        // 00100101     результат (37)
        System.out.println(n1^=n2); // производит операцию и присваивает переменной n1 значение побитового OR
        n1=42; // вернул первоначальное значение переменной

        // 5. Сдвиг вправо
        System.out.println(n1>>n2);
        // Все восемь бит теряются, значение 00000000 (0)
        // по сути сдвиг влево равен делению на 2 в степени сдвига с отбрасываением остатка: 42 / 2^15
        System.out.println(n2>>n1);
        // то же самое
        System.out.println(n1>>2);
        // 00101010     42
        // 00001010     результат (10)
        System.out.println(n2>>3);
        // 00001111     15
        // 00000001     результат (1)
        System.out.println(n2>>=3); // присваивание переменной n2 значения операции n2>>=3
        n2=15; // вернул первоначальное значение переменной

        // 6. Нулевой сдвиг вправо
        System.out.println(n1>>>n2);
        // Все восемь бит теряются, значение 00000000 (0)
        // по сути сдвиг влево равен делению на 2 в степени сдвига с отбрасываением остатка: 42 / 2^15
        // если правильно понял, для положительных чисел то же, что и просто сдвиг вправе, потому что
        // значение левого бита всегда заполняется 0 при нулевом сдвиге вправе
        System.out.println(n2>>>n1);
        // то же самое
        System.out.println(n1>>>2);
        // 00101010     42
        // 00001010     результат (10)
        System.out.println(n2>>>3);
        // 00001111     15
        // 00000001     результат (1)
        System.out.println(n2>>>=3); // присваивание переменной n2 значения операции n2>>>=3
        n2=15; // вернул первоначальное значение переменной

        // 7. Сдвиг влево
        System.out.println(n1<<n2);
        // для типа int размер может увеличиваться до 32 бит, получается 00101010_00000_00000_00000
        // по сути сдвиг влево равен умножению на 2 в степени сдвига: 42 * 2^15.
        System.out.println(n2<<n1);
        // если правильно понимаю, с учетом ограничение в 32 бит происходит "отсечение" 32, т.е. сдвиг не на 42, а на 10
        // в итоге получается 00001111_00000_00000
        System.out.println(n1<<2);
        // 00101010         42
        // 0000_0000_1010_1000       результат (168)
        System.out.println(n2<<3);
        // 00001111         15
        // 01111000       результат (120)
        System.out.println(n2<<=3); // присваивание переменной n2 значения операции n2<<=3
        n2=15; // вернул первоначальное значение переменной

        //пробуем с дробным числом
        double num1 = 42.5;
        // System.out.println(num1 & 12);
        // выдает ошибку "bad operand types"
    }
}
